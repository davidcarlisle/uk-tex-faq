<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Q-isitanum</title>
<link rel="stylesheet" href="faq.css">
</head>
<body>
<div class="breadcrumbs">
<a href="index.html">FAQ</a> &gt; <a href="index.html#Macroprogramming">Macro programming</a> &gt; <a href="index.html#ldquoGenericrdquomacrosandtechniques">&ldquo;Generic&rdquo; macros and techniques</a> &gt; <a href="index.html#Q-isitanum">Is the argument a number?</a>
</div>
<h1>Is the argument a number?</h1>


<p>

<p>
TeX&rsquo;s own lexical analysis doesn&rsquo;t offer the macro programmer
terribly much support: while category codes will distinguish letters
(or what TeX currently thinks of as letters) from everything else,
there&rsquo;s no support for analysing numbers.

<p>
The simple-minded solution is to compare numeric characters with the
characters of the argument, one by one, by a sequence of direct tests,
and to declare the argument &ldquo;not a number&rdquo; if any character fails
all comparisons:
<blockquote>
<pre>
\ifx1#1
\else\ifx2#1
...
\else\ifx9#1
\else\isanumfalse
\fi\fi...\fi
</pre>
</blockquote>
which one would then use in a tail-recursing macro to gobble an
argument.  One could do slightly better by assuming (pretty safely)
that the digits&rsquo; character codes are consecutive:
<blockquote>
<pre>
\ifnum`#1<`0 \isanumfalse
\else\ifnum`#1>`9 \isanumfalse
     \fi
\fi
</pre>
</blockquote>
again used in tail-recursion.  However, these forms aren&rsquo;t very
satisfactory: getting the recursion &ldquo;right&rdquo; is troublesome (it has a
tendency to gobble spaces in the argument), and in any case TeX
itself has mechanisms for reading numbers, and it would be nice to use
them.

<p>
Donald Arseneau&rsquo;s <i class="package">cite</i> package offers the following test
for an argument being a strictly positive integer:
<blockquote>
<pre>
\def\IsPositive#1{%
  TT\fi
  \ifcat_\ifnum0<0#1 _\else A\fi
}
</pre>
</blockquote>
which can be adapted to a test for a non-negative integer thus:
<blockquote>
<pre>
\def\IsNonNegative{%
  \ifcat_\ifnum9<1#1 _\else A\fi
}
</pre>
</blockquote>
or a test for any integer:
<blockquote>
<pre>
\def\gobbleminus#1{\ifx-#1\else#1\fi}
\def\IsInteger#1{%
  TT\fi
  \ifcat_\ifnum9<1\gobbleminus#1 _\else A\fi
}
</pre>
</blockquote>
but this surely stretches the technique further than is reasonable.

<p>
If we don&rsquo;t care about the sign, we can use TeX to remove the
entire number (sign and all) from the input stream, and then look at
what&rsquo;s left:
<blockquote>

<pre>
\def\testnum#1{\afterassignment\testresult
               \count255=0#1 \end}
\def\testresult#1\end{\ifx\end#1\end}
</pre>


<pre>
\def\testnum#1{\afterassignment\testresult\count255=0#1 \end}
\def\testresult#1\end{\ifx\end#1\end\isanumtrue\else\isanumfalse\fi}
</pre>

</blockquote>
(which technique is due to David Kastrup; the trick for avoiding the
errors, noted in an earlier version of this answer, was suggested by
Andreas Matthias).
In a later thread on the same topic, Michael Downes offered:
<blockquote>

<pre>
\def\IsInteger#1{%
  TT\fi
  \begingroup \lccode`\-=`\0 \lccode`+=`\0
    \lccode`\1=`\0 \lccode`\2=`\0 \lccode`\3=`\0
    \lccode`\4=`\0 \lccode`\5=`\0 \lccode`\6=`\0
    \lccode`\7=`\0 \lccode`\8=`\0 \lccode`\9=`\0
  \lowercase{\endgroup
    \expandafter\ifx\expandafter\delimiter
    \romannumeral0\string#1}\delimiter
}
</pre>


<pre>
\def\IsInteger#1{%
  TT\fi
  \begingroup \lccode`\-=`\0 \lccode`+=`\0
    \lccode`\1=`\0 \lccode`\2=`\0
    \lccode`\3=`\0 \lccode`\4=`\0
    \lccode`\5=`\0 \lccode`\6=`\0
    \lccode`\7=`\0 \lccode`\8=`\0
    \lccode`\9=`\0
  \lowercase{\endgroup
    \expandafter\ifx\expandafter\delimiter
    \romannumeral0\string#1}\delimiter
}
</pre>

</blockquote>
which relies on <code>&#x5c;romannumeral</code> producing an empty result if its
argument is zero.  Sadly, this technique has the unfortunate property
that it accepts simple expressions such as &lsquo;<tt>1+2-3</tt>&rsquo;; this
could be solved by an initial <code>&#x5c;gobbleminus</code>-like construction.

<p>
All the complete functions above are designed to be used in TeX
conditionals written &ldquo;naturally&rdquo;&nbsp;&mdash; for example:
<blockquote>
<pre>
\if\IsInteger{<subject of test>}%
  <deal with integer>%
\else
  <deal with non-integer>%
\fi
</pre>
</blockquote>
The LaTeX <i class="class">memoir</i> class has an internal command of its own,
<code>&#x5c;checkifinteger</code><code>&#x7b;num&#x7d;</code>, that sets the conditional command
<code>&#x5c;ifinteger</code> according to whether the argument was an integer.

<p>
Of course, all this kerfuffle would be (essentially) void if there was
a simple means of &ldquo;catching&rdquo; TeX errors.  Imagining an
error-catching primitive <code>&#x5c;ifnoerror</code>, one might write:
<blockquote>
<pre>
\def\IsInteger#1{%
  TT%
  \ifnoerror
    \tempcount=#1\relax
% carries on if no error
    \expandafter\iftrue
  \else
% here if there was an error
    \expandafter\iffalse
  \fi
}
</pre>
</blockquote>
thus using TeX&rsquo;s own integer-parsing code to do the check.  It&rsquo;s a
pity that such a mechanism was never defined (it could be that it&rsquo;s
impossible to program within TeX!).
<dl>
<dt class="ctanref">memoir.cls</dt><dd><a class="ctan" href="https://www.ctan.org/pkg/memoir">memoir</a>
</dl>

<p>

<hr><p class="faqlink">This question on the Web: <a href="http://www.tex.ac.uk/cgi-bin/texfaq2html?label=isitanum">http://www.tex.ac.uk/cgi-bin/texfaq2html?label=isitanum</a></p>
